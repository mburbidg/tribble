GQLProgram
    = programActivity sessionCloseCommand?
    | sessionCloseCommand
    ;

programActivity
    = sessionActivity
    | transactionActivity
    ;

sessionActivity
    = sessionResetCommand+
    | sessionSetCommand+ (sessionResetCommand+)?
    ;

transactionActivity
    = startTransactionCommand (procedureSpecification endTransactionCommand?)?
    | procedureSpecification endTransactionCommand?
    | endTransactionCommand
    ;

endTransactionCommand
    = rollbackCommand
    | commitCommand
    ;

sessionSetCommand
    = " SESSION " " SET " (sessionSetSchemaClause | sessionSetGraphClause | sessionSetTimeZoneClause | sessionSetParameterClause)
    ;

sessionSetSchemaClause
    = " SCHEMA " schemaReference
    ;

sessionSetGraphClause
    = " PROPERTY "? " GRAPH " graphExpression
    ;

sessionSetTimeZoneClause
    = " TIME " " ZONE " setTimeZoneValue
    ;

setTimeZoneValue
    = timeZoneString
    ;

sessionSetParameterClause
    = sessionSetGraphParameterClause
    | sessionSetBindingTableParameterClause
    | sessionSetValueParameterClause
    ;

sessionSetGraphParameterClause
    = " PROPERTY "? " GRAPH " sessionSetParameterName optTypedGraphInitializer
    ;

sessionSetBindingTableParameterClause
    = " BINDING "? " TABLE " sessionSetParameterName optTypedBindingTableInitializer
    ;

sessionSetValueParameterClause
    = " VALUE " sessionSetParameterName optTypedValueInitializer
    ;

sessionSetParameterName
    = (" IF " " NOT " " EXISTS ")? sessionParameterSpecification
    ;

sessionResetCommand
    = " SESSION " " RESET " sessionResetArguments?
    ;

sessionResetArguments
    = " ALL "? (" PARAMETERS " | " CHARACTERISTICS ")
    | " SCHEMA "
    | " PROPERTY "? " GRAPH "
    | " TIME " " ZONE "
    | " PARAMETER "? sessionParameterSpecification
    ;

sessionCloseCommand
    = " SESSION " " CLOSE "
    ;

sessionParameterSpecification
    = generalParameterReference
    ;

startTransactionCommand
    = " START " " TRANSACTION " transactionCharacteristics?
    ;

transactionCharacteristics
    = transactionMode (( whitespace comma whitespace  transactionMode)+)?
    ;

transactionMode
    = transactionAccessMode
    ;

transactionAccessMode
    = " READ " " ONLY "
    | " READ " " WRITE "
    ;

rollbackCommand
    = " ROLLBACK "
    ;

commitCommand
    = " COMMIT "
    ;

nestedProcedureSpecification
    =  whitespace leftBrace whitespace  procedureSpecification whitespace  rightBrace whitespace 
    ;

procedureSpecification
    = catalogModifyingProcedureSpecification
    | dataModifyingProcedureSpecification
    | querySpecification
    ;

catalogModifyingProcedureSpecification
    = procedureBody
    ;

nestedDataModifyingProcedureSpecification
    =  whitespace leftBrace whitespace  dataModifyingProcedureSpecification whitespace  rightBrace whitespace 
    ;

dataModifyingProcedureSpecification
    = procedureBody
    ;

nestedQuerySpecification
    =  whitespace leftBrace whitespace  querySpecification whitespace  rightBrace whitespace 
    ;

querySpecification
    = procedureBody
    ;

procedureBody
    = atSchemaClause? bindingVariableDefinitionBlock? statementBlock
    ;

bindingVariableDefinitionBlock
    = bindingVariableDefinition+
    ;

bindingVariableDefinition
    = graphVariableDefinition
    | bindingTableVariableDefinition
    | valueVariableDefinition
    ;

statementBlock
    = statement (nextStatement+)?
    ;

statement
    = linearCatalogModifyingStatement
    | linearDataModifyingStatement
    | compositeQueryStatement
    ;

nextStatement
    = " NEXT " yieldClause? statement
    ;

graphVariableDefinition
    = " PROPERTY "? " GRAPH " bindingVariable optTypedGraphInitializer
    ;

optTypedGraphInitializer
    = (typed? graphReferenceValueType)? graphInitializer
    ;

graphInitializer
    =  whitespace equalsOperator whitespace  graphExpression
    ;

bindingTableVariableDefinition
    = " BINDING "? " TABLE " bindingVariable optTypedBindingTableInitializer
    ;

optTypedBindingTableInitializer
    = (typed? bindingTableReferenceValueType)? bindingTableInitializer
    ;

bindingTableInitializer
    =  whitespace equalsOperator whitespace  bindingTableExpression
    ;

valueVariableDefinition
    = " VALUE " bindingVariable optTypedValueInitializer
    ;

optTypedValueInitializer
    = (typed? valueType)? valueInitializer
    ;

valueInitializer
    =  whitespace equalsOperator whitespace  valueExpression
    ;

graphExpression
    = objectExpressionPrimary
    | graphReference
    | objectNameOrBindingVariable
    | currentGraph
    ;

currentGraph
    = " CURRENT_PROPERTY_GRAPH "
    | " CURRENT_GRAPH "
    ;

bindingTableExpression
    = nestedBindingTableQuerySpecification
    | objectExpressionPrimary
    | bindingTableReference
    | objectNameOrBindingVariable
    ;

nestedBindingTableQuerySpecification
    = nestedQuerySpecification
    ;

objectExpressionPrimary
    = " VARIABLE " valueExpressionPrimary
    | parenthesizedValueExpression
    | nonParenthesizedValueExpressionPrimarySpecialCase
    ;

linearCatalogModifyingStatement
    = simpleCatalogModifyingStatement+
    ;

simpleCatalogModifyingStatement
    = primitiveCatalogModifyingStatement
    | callCatalogModifyingProcedureStatement
    ;

primitiveCatalogModifyingStatement
    = createSchemaStatement
    | dropSchemaStatement
    | createGraphStatement
    | dropGraphStatement
    | createGraphTypeStatement
    | dropGraphTypeStatement
    ;

createSchemaStatement
    = " CREATE " " SCHEMA " (" IF " " NOT " " EXISTS ")? catalogSchemaParentAndName
    ;

dropSchemaStatement
    = " DROP " " SCHEMA " (" IF " " EXISTS ")? catalogSchemaParentAndName
    ;

createGraphStatement
    = " CREATE " (" PROPERTY "? " GRAPH " (" IF " " NOT " " EXISTS ")? | " OR " " REPLACE " " PROPERTY "? " GRAPH ") catalogGraphParentAndName (openGraphType | ofGraphType) graphSource?
    ;

openGraphType
    = typed? " ANY " (" PROPERTY "? " GRAPH ")?
    ;

ofGraphType
    = graphTypeLikeGraph
    | typed? graphTypeReference
    | typed? (" PROPERTY "? " GRAPH ")? nestedGraphTypeSpecification
    ;

graphTypeLikeGraph
    = " LIKE " graphExpression
    ;

graphSource
    = " AS " " COPY " " OF " graphExpression
    ;

dropGraphStatement
    = " DROP " " PROPERTY "? " GRAPH " (" IF " " EXISTS ")? catalogGraphParentAndName
    ;

createGraphTypeStatement
    = " CREATE " (" PROPERTY "? " GRAPH " " TYPE " (" IF " " NOT " " EXISTS ")? | " OR " " REPLACE " " PROPERTY "? " GRAPH " " TYPE ") catalogGraphTypeParentAndName graphTypeSource
    ;

graphTypeSource
    = " AS "? copyOfGraphType
    | graphTypeLikeGraph
    | " AS "? nestedGraphTypeSpecification
    ;

copyOfGraphType
    = " COPY " " OF " (graphTypeReference)
    ;

dropGraphTypeStatement
    = " DROP " " PROPERTY "? " GRAPH " " TYPE " (" IF " " EXISTS ")? catalogGraphTypeParentAndName
    ;

callCatalogModifyingProcedureStatement
    = callProcedureStatement
    ;

linearDataModifyingStatement
    = focusedLinearDataModifyingStatement
    | ambientLinearDataModifyingStatement
    ;

focusedLinearDataModifyingStatement
    = focusedLinearDataModifyingStatementBody
    | focusedNestedDataModifyingProcedureSpecification
    ;

focusedLinearDataModifyingStatementBody
    = useGraphClause simpleLinearDataAccessingStatement primitiveResultStatement?
    ;

focusedNestedDataModifyingProcedureSpecification
    = useGraphClause nestedDataModifyingProcedureSpecification
    ;

ambientLinearDataModifyingStatement
    = ambientLinearDataModifyingStatementBody
    | nestedDataModifyingProcedureSpecification
    ;

ambientLinearDataModifyingStatementBody
    = simpleLinearDataAccessingStatement primitiveResultStatement?
    ;

simpleLinearDataAccessingStatement
    = simpleDataAccessingStatement+
    ;

simpleDataAccessingStatement
    = simpleQueryStatement
    | simpleDataModifyingStatement
    ;

simpleDataModifyingStatement
    = primitiveDataModifyingStatement
    | callDataModifyingProcedureStatement
    ;

primitiveDataModifyingStatement
    = insertStatement
    | setStatement
    | removeStatement
    | deleteStatement
    ;

insertStatement
    = " INSERT " insertGraphPattern
    ;

setStatement
    = " SET " setItemList
    ;

setItemList
    = setItem (( whitespace comma whitespace  setItem)+)?
    ;

setItem
    = setPropertyItem
    | setAllPropertiesItem
    | setLabelItem
    ;

setPropertyItem
    = bindingVariableReference whitespace  period whitespace  propertyName whitespace  equalsOperator whitespace  valueExpression
    ;

setAllPropertiesItem
    = bindingVariableReference whitespace  equalsOperator whitespace  whitespace  leftBrace whitespace  propertyKeyValuePairList? whitespace  rightBrace whitespace 
    ;

setLabelItem
    = bindingVariableReference isOrColon labelName
    ;

removeStatement
    = " REMOVE " removeItemList
    ;

removeItemList
    = removeItem (( whitespace comma whitespace  removeItem)+)?
    ;

removeItem
    = removePropertyItem
    | removeLabelItem
    ;

removePropertyItem
    = bindingVariableReference whitespace  period whitespace  propertyName
    ;

removeLabelItem
    = bindingVariableReference isOrColon labelName
    ;

deleteStatement
    = (" DETACH " | " NODETACH ")? " DELETE " deleteItemList
    ;

deleteItemList
    = deleteItem (( whitespace comma whitespace  deleteItem)+)?
    ;

deleteItem
    = valueExpression
    ;

callDataModifyingProcedureStatement
    = callProcedureStatement
    ;

compositeQueryStatement
    = compositeQueryExpression
    ;

compositeQueryExpression
    = compositeQueryExpression queryConjunction compositeQueryPrimary
    | compositeQueryPrimary
    ;

queryConjunction
    = setOperator
    | " OTHERWISE "
    ;

setOperator
    = " UNION " setQuantifier?
    | " EXCEPT " setQuantifier?
    | " INTERSECT " setQuantifier?
    ;

compositeQueryPrimary
    = linearQueryStatement
    ;

linearQueryStatement
    = focusedLinearQueryStatement
    | ambientLinearQueryStatement
    ;

focusedLinearQueryStatement
    = (focusedLinearQueryStatementPart+)? focusedLinearQueryAndPrimitiveResultStatementPart
    | focusedPrimitiveResultStatement
    | focusedNestedQuerySpecification
    | selectStatement
    ;

focusedLinearQueryStatementPart
    = useGraphClause simpleLinearQueryStatement
    ;

focusedLinearQueryAndPrimitiveResultStatementPart
    = useGraphClause simpleLinearQueryStatement primitiveResultStatement
    ;

focusedPrimitiveResultStatement
    = useGraphClause primitiveResultStatement
    ;

focusedNestedQuerySpecification
    = useGraphClause nestedQuerySpecification
    ;

ambientLinearQueryStatement
    = simpleLinearQueryStatement? primitiveResultStatement
    | nestedQuerySpecification
    ;

simpleLinearQueryStatement
    = simpleQueryStatement+
    ;

simpleQueryStatement
    = primitiveQueryStatement
    | callQueryStatement
    ;

primitiveQueryStatement
    = matchStatement
    | letStatement
    | forStatement
    | filterStatement
    | orderByAndPageStatement
    ;

matchStatement
    = simpleMatchStatement
    | optionalMatchStatement
    ;

simpleMatchStatement
    = " MATCH " graphPatternBindingTable
    ;

optionalMatchStatement
    = " OPTIONAL " optionalOperand
    ;

optionalOperand
    = simpleMatchStatement
    |  whitespace leftBrace whitespace  matchStatementBlock whitespace  rightBrace whitespace 
    |  whitespace leftParen whitespace  matchStatementBlock whitespace  rightParen whitespace 
    ;

matchStatementBlock
    = matchStatement+
    ;

callQueryStatement
    = callProcedureStatement
    ;

filterStatement
    = " FILTER " (whereClause | searchCondition)
    ;

letStatement
    = " LET " letVariableDefinitionList
    ;

letVariableDefinitionList
    = letVariableDefinition (( whitespace comma whitespace  letVariableDefinition)+)?
    ;

letVariableDefinition
    = valueVariableDefinition
    | bindingVariable whitespace  equalsOperator whitespace  valueExpression
    ;

forStatement
    = " FOR " forItem forOrdinalityOrOffset?
    ;

forItem
    = forItemAlias forItemSource
    ;

forItemAlias
    = bindingVariable " IN "
    ;

forItemSource
    = listValueExpression
    | bindingTableReferenceValueExpression
    ;

forOrdinalityOrOffset
    = " WITH " (" ORDINALITY " | " OFFSET ") bindingVariable
    ;

orderByAndPageStatement
    = orderByClause offsetClause? limitClause?
    | offsetClause limitClause?
    | limitClause
    ;

primitiveResultStatement
    = returnStatement orderByAndPageStatement?
    | " FINISH "
    ;

returnStatement
    = " RETURN " returnStatementBody
    ;

returnStatementBody
    = setQuantifier? ( whitespace asterisk whitespace  | returnItemList) groupByClause?
    | " NO " " BINDINGS "
    ;

returnItemList
    = returnItem (( whitespace comma whitespace  returnItem)+)?
    ;

returnItem
    = aggregatingValueExpression returnItemAlias?
    ;

returnItemAlias
    = " AS " identifier
    ;

selectStatement
    = " SELECT " setQuantifier? ( whitespace asterisk whitespace  | selectItemList) (selectStatementBody whereClause? groupByClause? havingClause? orderByClause? offsetClause? limitClause?)?
    ;

selectItemList
    = selectItem (( whitespace comma whitespace  selectItem)+)?
    ;

selectItem
    = aggregatingValueExpression selectItemAlias?
    ;

selectItemAlias
    = " AS " identifier
    ;

havingClause
    = " HAVING " searchCondition
    ;

selectStatementBody
    = " FROM " (selectGraphMatchList | selectQuerySpecification)
    ;

selectGraphMatchList
    = selectGraphMatch (( whitespace comma whitespace  selectGraphMatch)+)?
    ;

selectGraphMatch
    = graphExpression matchStatement
    ;

selectQuerySpecification
    = nestedQuerySpecification
    | graphExpression nestedQuerySpecification
    ;

callProcedureStatement
    = " OPTIONAL "? " CALL " procedureCall
    ;

procedureCall
    = inlineProcedureCall
    | namedProcedureCall
    ;

inlineProcedureCall
    = variableScopeClause? nestedProcedureSpecification
    ;

variableScopeClause
    =  whitespace leftParen whitespace  bindingVariableReferenceList? whitespace  rightParen whitespace 
    ;

bindingVariableReferenceList
    = bindingVariableReference (( whitespace comma whitespace  bindingVariableReference)+)?
    ;

namedProcedureCall
    = procedureReference whitespace  leftParen whitespace  procedureArgumentList? whitespace  rightParen whitespace  yieldClause?
    ;

procedureArgumentList
    = procedureArgument (( whitespace comma whitespace  procedureArgument)+)?
    ;

procedureArgument
    = valueExpression
    ;

atSchemaClause
    = " AT " schemaReference
    ;

useGraphClause
    = " USE " graphExpression
    ;

graphPatternBindingTable
    = graphPattern graphPatternYieldClause?
    ;

graphPatternYieldClause
    = " YIELD " graphPatternYieldItemList
    ;

graphPatternYieldItemList
    = graphPatternYieldItem (( whitespace comma whitespace  graphPatternYieldItem)+)?
    | " NO " " BINDINGS "
    ;

graphPatternYieldItem
    = elementVariableReference
    | pathVariableReference
    ;

graphPattern
    = matchMode? pathPatternList keepClause? graphPatternWhereClause?
    ;

matchMode
    = repeatableElementsMatchMode
    | differentEdgesMatchMode
    ;

repeatableElementsMatchMode
    = " REPEATABLE " elementBindingsOrElements
    ;

differentEdgesMatchMode
    = " DIFFERENT " edgeBindingsOrEdges
    ;

elementBindingsOrElements
    = " ELEMENT " " BINDINGS "?
    | " ELEMENTS "
    ;

edgeBindingsOrEdges
    = edgeSynonym " BINDINGS "?
    | edgesSynonym
    ;

pathPatternList
    = pathPattern (( whitespace comma whitespace  pathPattern)+)?
    ;

pathPattern
    = pathVariableDeclaration? pathPatternPrefix? pathPatternExpression
    ;

pathVariableDeclaration
    = pathVariable whitespace  equalsOperator whitespace 
    ;

keepClause
    = " KEEP " pathPatternPrefix
    ;

graphPatternWhereClause
    = " WHERE " searchCondition
    ;

insertGraphPattern
    = insertPathPatternList
    ;

insertPathPatternList
    = insertPathPattern (( whitespace comma whitespace  insertPathPattern)+)?
    ;

insertPathPattern
    = insertNodePattern ((insertEdgePattern insertNodePattern)+)?
    ;

insertNodePattern
    =  whitespace leftParen whitespace  insertElementPatternFiller? whitespace  rightParen whitespace 
    ;

insertEdgePattern
    = insertEdgePointingLeft
    | insertEdgePointingRight
    | insertEdgeUndirected
    ;

insertEdgePointingLeft
    =  whitespace leftArrowBracket whitespace  insertElementPatternFiller? whitespace  rightBracketMinus whitespace 
    ;

insertEdgePointingRight
    =  whitespace minusLeftBracket whitespace  insertElementPatternFiller? whitespace  bracketRightArrow whitespace 
    ;

insertEdgeUndirected
    =  whitespace tildeLeftBracket whitespace  insertElementPatternFiller? whitespace  rightBracketTilde whitespace 
    ;

insertElementPatternFiller
    = elementVariableDeclaration labelAndPropertySetSpecification?
    | elementVariableDeclaration? labelAndPropertySetSpecification
    ;

labelAndPropertySetSpecification
    = isOrColon labelSetSpecification elementPropertySpecification?
    | (isOrColon labelSetSpecification)? elementPropertySpecification
    ;

pathPatternPrefix
    = pathModePrefix
    | pathSearchPrefix
    ;

pathModePrefix
    = pathMode pathOrPaths?
    ;

pathMode
    = " WALK "
    | " TRAIL "
    | " SIMPLE "
    | " ACYCLIC "
    ;

pathSearchPrefix
    = allPathSearch
    | anyPathSearch
    | shortestPathSearch
    ;

allPathSearch
    = " ALL " pathMode? pathOrPaths?
    ;

pathOrPaths
    = " PATH "
    | " PATHS "
    ;

anyPathSearch
    = " ANY " numberOfPaths? pathMode? pathOrPaths?
    ;

numberOfPaths
    = nonNegativeIntegerSpecification
    ;

shortestPathSearch
    = allShortestPathSearch
    | anyShortestPathSearch
    | countedShortestPathSearch
    | countedShortestGroupSearch
    ;

allShortestPathSearch
    = " ALL " " SHORTEST " pathMode? pathOrPaths?
    ;

anyShortestPathSearch
    = " ANY " " SHORTEST " pathMode? pathOrPaths?
    ;

countedShortestPathSearch
    = " SHORTEST " numberOfPaths pathMode? pathOrPaths?
    ;

countedShortestGroupSearch
    = " SHORTEST " numberOfGroups? pathMode? pathOrPaths? (" GROUP " | " GROUPS ")
    ;

numberOfGroups
    = nonNegativeIntegerSpecification
    ;

pathPatternExpression
    = pathTerm
    | pathMultisetAlternation
    | pathPatternUnion
    ;

pathMultisetAlternation
    = pathTerm whitespace  multisetAlternationOperator whitespace  pathTerm (( whitespace multisetAlternationOperator whitespace  pathTerm)+)?
    ;

pathPatternUnion
    = pathTerm whitespace  verticalBar whitespace  pathTerm (( whitespace verticalBar whitespace  pathTerm)+)?
    ;

pathTerm
    = pathFactor
    | pathConcatenation
    ;

pathConcatenation
    = pathTerm pathFactor
    ;

pathFactor
    = pathPrimary
    | quantifiedPathPrimary
    | questionedPathPrimary
    ;

quantifiedPathPrimary
    = pathPrimary graphPatternQuantifier
    ;

questionedPathPrimary
    = pathPrimary whitespace  questionMark whitespace 
    ;

pathPrimary
    = elementPattern
    | parenthesizedPathPatternExpression
    | simplifiedPathPatternExpression
    ;

elementPattern
    = nodePattern
    | edgePattern
    ;

nodePattern
    =  whitespace leftParen whitespace  elementPatternFiller whitespace  rightParen whitespace 
    ;

elementPatternFiller
    = elementVariableDeclaration? isLabelExpression? elementPatternPredicate?
    ;

elementVariableDeclaration
    = " TEMP "? elementVariable
    ;

isLabelExpression
    = isOrColon labelExpression
    ;

isOrColon
    = " IS "
    |  whitespace colon whitespace 
    ;

elementPatternPredicate
    = elementPatternWhereClause
    | elementPropertySpecification
    ;

elementPatternWhereClause
    = " WHERE " searchCondition
    ;

elementPropertySpecification
    =  whitespace leftBrace whitespace  propertyKeyValuePairList whitespace  rightBrace whitespace 
    ;

propertyKeyValuePairList
    = propertyKeyValuePair (( whitespace comma whitespace  propertyKeyValuePair)+)?
    ;

propertyKeyValuePair
    = propertyName whitespace  colon whitespace  valueExpression
    ;

edgePattern
    = fullEdgePattern
    | abbreviatedEdgePattern
    ;

fullEdgePattern
    = fullEdgePointingLeft
    | fullEdgeUndirected
    | fullEdgePointingRight
    | fullEdgeLeftOrUndirected
    | fullEdgeUndirectedOrRight
    | fullEdgeLeftOrRight
    | fullEdgeAnyDirection
    ;

fullEdgePointingLeft
    =  whitespace leftArrowBracket whitespace  elementPatternFiller whitespace  rightBracketMinus whitespace 
    ;

fullEdgeUndirected
    =  whitespace tildeLeftBracket whitespace  elementPatternFiller whitespace  rightBracketTilde whitespace 
    ;

fullEdgePointingRight
    =  whitespace minusLeftBracket whitespace  elementPatternFiller whitespace  bracketRightArrow whitespace 
    ;

fullEdgeLeftOrUndirected
    =  whitespace leftArrowTildeBracket whitespace  elementPatternFiller whitespace  rightBracketTilde whitespace 
    ;

fullEdgeUndirectedOrRight
    =  whitespace tildeLeftBracket whitespace  elementPatternFiller whitespace  bracketTildeRightArrow whitespace 
    ;

fullEdgeLeftOrRight
    =  whitespace leftArrowBracket whitespace  elementPatternFiller whitespace  bracketRightArrow whitespace 
    ;

fullEdgeAnyDirection
    =  whitespace minusLeftBracket whitespace  elementPatternFiller whitespace  rightBracketMinus whitespace 
    ;

abbreviatedEdgePattern
    =  whitespace leftArrow whitespace 
    |  whitespace tilde whitespace 
    |  whitespace rightArrow whitespace 
    |  whitespace leftArrowTilde whitespace 
    |  whitespace tildeRightArrow whitespace 
    |  whitespace leftMinusRight whitespace 
    |  whitespace minusSign whitespace 
    ;

parenthesizedPathPatternExpression
    =  whitespace leftParen whitespace  subpathVariableDeclaration? pathModePrefix? pathPatternExpression parenthesizedPathPatternWhereClause? whitespace  rightParen whitespace 
    ;

subpathVariableDeclaration
    = subpathVariable whitespace  equalsOperator whitespace 
    ;

parenthesizedPathPatternWhereClause
    = " WHERE " searchCondition
    ;

labelExpression
    = labelTerm
    | labelDisjunction
    ;

labelDisjunction
    = labelExpression whitespace  verticalBar whitespace  labelTerm
    ;

labelTerm
    = labelFactor
    | labelConjunction
    ;

labelConjunction
    = labelTerm whitespace  ampersand whitespace  labelFactor
    ;

labelFactor
    = labelPrimary
    | labelNegation
    ;

labelNegation
    =  whitespace exclamationMark whitespace  labelPrimary
    ;

labelPrimary
    = labelName
    | wildcardLabel
    | parenthesizedLabelExpression
    ;

wildcardLabel
    =  whitespace percent whitespace 
    ;

parenthesizedLabelExpression
    =  whitespace leftParen whitespace  labelExpression whitespace  rightParen whitespace 
    ;

pathVariableReference
    = bindingVariableReference
    ;

elementVariableReference
    = bindingVariableReference
    ;

graphPatternQuantifier
    =  whitespace asterisk whitespace 
    |  whitespace plusSign whitespace 
    | fixedQuantifier
    | generalQuantifier
    ;

fixedQuantifier
    =  whitespace leftBrace whitespace  unsignedInteger whitespace  rightBrace whitespace 
    ;

generalQuantifier
    =  whitespace leftBrace whitespace  lowerBound? whitespace  comma whitespace  upperBound? whitespace  rightBrace whitespace 
    ;

lowerBound
    = unsignedInteger
    ;

upperBound
    = unsignedInteger
    ;

simplifiedPathPatternExpression
    = simplifiedDefaultingLeft
    | simplifiedDefaultingUndirected
    | simplifiedDefaultingRight
    | simplifiedDefaultingLeftOrUndirected
    | simplifiedDefaultingUndirectedOrRight
    | simplifiedDefaultingLeftOrRight
    | simplifiedDefaultingAnyDirection
    ;

simplifiedDefaultingLeft
    =  whitespace leftMinusSlash whitespace  simplifiedContents whitespace  slashMinus whitespace 
    ;

simplifiedDefaultingUndirected
    =  whitespace tildeSlash whitespace  simplifiedContents whitespace  slashTilde whitespace 
    ;

simplifiedDefaultingRight
    =  whitespace minusSlash whitespace  simplifiedContents whitespace  slashMinusRight whitespace 
    ;

simplifiedDefaultingLeftOrUndirected
    =  whitespace leftTildeSlash whitespace  simplifiedContents whitespace  slashTilde whitespace 
    ;

simplifiedDefaultingUndirectedOrRight
    =  whitespace tildeSlash whitespace  simplifiedContents whitespace  slashTildeRight whitespace 
    ;

simplifiedDefaultingLeftOrRight
    =  whitespace leftMinusSlash whitespace  simplifiedContents whitespace  slashMinusRight whitespace 
    ;

simplifiedDefaultingAnyDirection
    =  whitespace minusSlash whitespace  simplifiedContents whitespace  slashMinus whitespace 
    ;

simplifiedContents
    = simplifiedTerm
    | simplifiedPathUnion
    | simplifiedMultisetAlternation
    ;

simplifiedPathUnion
    = simplifiedTerm whitespace  verticalBar whitespace  simplifiedTerm (( whitespace verticalBar whitespace  simplifiedTerm)+)?
    ;

simplifiedMultisetAlternation
    = simplifiedTerm whitespace  multisetAlternationOperator whitespace  simplifiedTerm (( whitespace multisetAlternationOperator whitespace  simplifiedTerm)+)?
    ;

simplifiedTerm
    = simplifiedFactorLow
    | simplifiedConcatenation
    ;

simplifiedConcatenation
    = simplifiedTerm simplifiedFactorLow
    ;

simplifiedFactorLow
    = simplifiedFactorHigh
    | simplifiedConjunction
    ;

simplifiedConjunction
    = simplifiedFactorLow whitespace  ampersand whitespace  simplifiedFactorHigh
    ;

simplifiedFactorHigh
    = simplifiedTertiary
    | simplifiedQuantified
    | simplifiedQuestioned
    ;

simplifiedQuantified
    = simplifiedTertiary graphPatternQuantifier
    ;

simplifiedQuestioned
    = simplifiedTertiary whitespace  questionMark whitespace 
    ;

simplifiedTertiary
    = simplifiedDirectionOverride
    | simplifiedSecondary
    ;

simplifiedDirectionOverride
    = simplifiedOverrideLeft
    | simplifiedOverrideUndirected
    | simplifiedOverrideRight
    | simplifiedOverrideLeftOrUndirected
    | simplifiedOverrideUndirectedOrRight
    | simplifiedOverrideLeftOrRight
    | simplifiedOverrideAnyDirection
    ;

simplifiedOverrideLeft
    =  whitespace leftAngleBracket whitespace  simplifiedSecondary
    ;

simplifiedOverrideUndirected
    =  whitespace tilde whitespace  simplifiedSecondary
    ;

simplifiedOverrideRight
    = simplifiedSecondary whitespace  rightAngleBracket whitespace 
    ;

simplifiedOverrideLeftOrUndirected
    =  whitespace leftArrowTilde whitespace  simplifiedSecondary
    ;

simplifiedOverrideUndirectedOrRight
    =  whitespace tilde whitespace  simplifiedSecondary whitespace  rightAngleBracket whitespace 
    ;

simplifiedOverrideLeftOrRight
    =  whitespace leftAngleBracket whitespace  simplifiedSecondary whitespace  rightAngleBracket whitespace 
    ;

simplifiedOverrideAnyDirection
    =  whitespace minusSign whitespace  simplifiedSecondary
    ;

simplifiedSecondary
    = simplifiedPrimary
    | simplifiedNegation
    ;

simplifiedNegation
    =  whitespace exclamationMark whitespace  simplifiedPrimary
    ;

simplifiedPrimary
    = labelName
    |  whitespace leftParen whitespace  simplifiedContents whitespace  rightParen whitespace 
    ;

whereClause
    = " WHERE " searchCondition
    ;

yieldClause
    = " YIELD " yieldItemList
    ;

yieldItemList
    = yieldItem (( whitespace comma whitespace  yieldItem)+)?
    ;

yieldItem
    = (yieldItemName yieldItemAlias?)
    ;

yieldItemName
    = fieldName
    ;

yieldItemAlias
    = " AS " bindingVariable
    ;

groupByClause
    = " GROUP " " BY " groupingElementList
    ;

groupingElementList
    = groupingElement (( whitespace comma whitespace  groupingElement)+)?
    | emptyGroupingSet
    ;

groupingElement
    = bindingVariableReference
    ;

emptyGroupingSet
    =  whitespace leftParen whitespace  whitespace  rightParen whitespace 
    ;

orderByClause
    = " ORDER " " BY " sortSpecificationList
    ;

sortSpecificationList
    = sortSpecification (( whitespace comma whitespace  sortSpecification)+)?
    ;

sortSpecification
    = sortKey orderingSpecification? nullOrdering?
    ;

sortKey
    = aggregatingValueExpression
    ;

orderingSpecification
    = " ASC "
    | " ASCENDING "
    | " DESC "
    | " DESCENDING "
    ;

nullOrdering
    = " NULLS " " FIRST "
    | " NULLS " " LAST "
    ;

limitClause
    = " LIMIT " nonNegativeIntegerSpecification
    ;

offsetClause
    = offsetSynonym nonNegativeIntegerSpecification
    ;

offsetSynonym
    = " OFFSET "
    | " SKIP "
    ;

schemaReference
    = absoluteCatalogSchemaReference
    | relativeCatalogSchemaReference
    | referenceParameterSpecification
    ;

absoluteCatalogSchemaReference
    =  whitespace solidus whitespace 
    | absoluteDirectoryPath schemaName
    ;

catalogSchemaParentAndName
    = absoluteDirectoryPath schemaName
    ;

relativeCatalogSchemaReference
    = predefinedSchemaReference
    | relativeDirectoryPath schemaName
    ;

predefinedSchemaReference
    = " HOME_SCHEMA "
    | " CURRENT_SCHEMA "
    |  whitespace period whitespace 
    ;

absoluteDirectoryPath
    =  whitespace solidus  simpleDirectoryPath?
    ;

relativeDirectoryPath
    =  whitespace doublePeriod (solidus  doublePeriod )* solidus simpleDirectoryPath?
    ;

simpleDirectoryPath
    = (directoryName  solidus)+
    ;

graphReference
    = catalogObjectParentReference graphName
    | delimitedGraphName
    | homeGraph
    | referenceParameterSpecification
    ;

catalogGraphParentAndName
    = catalogObjectParentReference? graphName
    ;

homeGraph
    = " HOME_PROPERTY_GRAPH "
    | " HOME_GRAPH "
    ;

graphTypeReference
    = catalogGraphTypeParentAndName
    | referenceParameterSpecification
    ;

catalogGraphTypeParentAndName
    = catalogObjectParentReference? graphTypeName
    ;

bindingTableReference
    = catalogObjectParentReference bindingTableName
    | delimitedBindingTableName
    | referenceParameterSpecification
    ;

procedureReference
    = catalogProcedureParentAndName
    | referenceParameterSpecification
    ;

catalogProcedureParentAndName
    = catalogObjectParentReference? procedureName
    ;

catalogObjectParentReference
    = schemaReference  whitespace solidus whitespace ? ((objectName whitespace  period whitespace )+)?
    | (objectName whitespace  period whitespace )+
    ;

referenceParameterSpecification
    = substitutedParameterReference
    ;

nestedGraphTypeSpecification
    =  whitespace leftBrace whitespace  graphTypeSpecificationBody whitespace  rightBrace whitespace 
    ;

graphTypeSpecificationBody
    = elementTypeList
    ;

elementTypeList
    = elementTypeSpecification (( whitespace comma whitespace  elementTypeSpecification)+)?
    ;

elementTypeSpecification
    = nodeTypeSpecification
    | edgeTypeSpecification
    ;

nodeTypeSpecification
    = nodeTypePattern
    | nodeTypePhrase
    ;

nodeTypePattern
    = (nodeSynonym " TYPE "? nodeTypeName)? whitespace  leftParen whitespace  localNodeTypeAlias? nodeTypeFiller? whitespace  rightParen whitespace 
    ;

nodeTypePhrase
    = nodeSynonym " TYPE "? nodeTypePhraseFiller (" AS " localNodeTypeAlias)?
    ;

nodeTypePhraseFiller
    = nodeTypeName nodeTypeFiller?
    | nodeTypeFiller
    ;

nodeTypeFiller
    = nodeTypeKeyLabelSet nodeTypeImpliedContent?
    | nodeTypeImpliedContent
    ;

localNodeTypeAlias
    = regularIdentifier
    ;

nodeTypeImpliedContent
    = nodeTypeLabelSet
    | nodeTypePropertyTypes
    | nodeTypeLabelSet nodeTypePropertyTypes
    ;

nodeTypeKeyLabelSet
    = labelSetPhrase? implies
    ;

nodeTypeLabelSet
    = labelSetPhrase
    ;

nodeTypePropertyTypes
    = propertyTypesSpecification
    ;

edgeTypeSpecification
    = edgeTypePattern
    | edgeTypePhrase
    ;

edgeTypePattern
    = (edgeKind? edgeSynonym " TYPE "? edgeTypeName)? (edgeTypePatternDirected | edgeTypePatternUndirected)
    ;

edgeTypePhrase
    = edgeKind edgeSynonym " TYPE "? edgeTypePhraseFiller endpointPairPhrase
    ;

edgeTypePhraseFiller
    = edgeTypeName edgeTypeFiller?
    | edgeTypeFiller
    ;

edgeTypeFiller
    = edgeTypeKeyLabelSet edgeTypeImpliedContent?
    | edgeTypeImpliedContent
    ;

edgeTypeImpliedContent
    = edgeTypeLabelSet
    | edgeTypePropertyTypes
    | edgeTypeLabelSet edgeTypePropertyTypes
    ;

edgeTypeKeyLabelSet
    = labelSetPhrase? implies
    ;

edgeTypeLabelSet
    = labelSetPhrase
    ;

edgeTypePropertyTypes
    = propertyTypesSpecification
    ;

edgeTypePatternDirected
    = edgeTypePatternPointingRight
    | edgeTypePatternPointingLeft
    ;

edgeTypePatternPointingRight
    = sourceNodeTypeReference arcTypePointingRight destinationNodeTypeReference
    ;

edgeTypePatternPointingLeft
    = destinationNodeTypeReference arcTypePointingLeft sourceNodeTypeReference
    ;

edgeTypePatternUndirected
    = sourceNodeTypeReference arcTypeUndirected destinationNodeTypeReference
    ;

arcTypePointingRight
    =  whitespace minusLeftBracket whitespace  edgeTypeFiller whitespace  bracketRightArrow whitespace 
    ;

arcTypePointingLeft
    =  whitespace leftArrowBracket whitespace  edgeTypeFiller whitespace  rightBracketMinus whitespace 
    ;

arcTypeUndirected
    =  whitespace tildeLeftBracket whitespace  edgeTypeFiller whitespace  rightBracketTilde whitespace 
    ;

sourceNodeTypeReference
    =  whitespace leftParen whitespace  sourceNodeTypeAlias whitespace  rightParen whitespace 
    |  whitespace leftParen whitespace  nodeTypeFiller? whitespace  rightParen whitespace 
    ;

destinationNodeTypeReference
    =  whitespace leftParen whitespace  destinationNodeTypeAlias whitespace  rightParen whitespace 
    |  whitespace leftParen whitespace  nodeTypeFiller? whitespace  rightParen whitespace 
    ;

edgeKind
    = " DIRECTED "
    | " UNDIRECTED "
    ;

endpointPairPhrase
    = " CONNECTING " endpointPair
    ;

endpointPair
    = endpointPairDirected
    | endpointPairUndirected
    ;

endpointPairDirected
    = endpointPairPointingRight
    | endpointPairPointingLeft
    ;

endpointPairPointingRight
    =  whitespace leftParen whitespace  sourceNodeTypeAlias connectorPointingRight destinationNodeTypeAlias whitespace  rightParen whitespace 
    ;

endpointPairPointingLeft
    =  whitespace leftParen whitespace  destinationNodeTypeAlias whitespace  leftArrow whitespace  sourceNodeTypeAlias whitespace  rightParen whitespace 
    ;

endpointPairUndirected
    =  whitespace leftParen whitespace  sourceNodeTypeAlias connectorUndirected destinationNodeTypeAlias whitespace  rightParen whitespace 
    ;

connectorPointingRight
    = " TO "
    |  whitespace rightArrow whitespace 
    ;

connectorUndirected
    = " TO "
    |  whitespace tilde whitespace 
    ;

sourceNodeTypeAlias
    = regularIdentifier
    ;

destinationNodeTypeAlias
    = regularIdentifier
    ;

labelSetPhrase
    = " LABEL " labelName
    | " LABELS " labelSetSpecification
    | isOrColon labelSetSpecification
    ;

labelSetSpecification
    = labelName (( whitespace ampersand whitespace  labelName)+)?
    ;

propertyTypesSpecification
    =  whitespace leftBrace whitespace  propertyTypeList? whitespace  rightBrace whitespace 
    ;

propertyTypeList
    = propertyType (( whitespace comma whitespace  propertyType)+)?
    ;

propertyType
    = propertyName typed? propertyValueType
    ;

propertyValueType
    = valueType
    ;

bindingTableType
    = " BINDING "? " TABLE " fieldTypesSpecification
    ;

valueType
    = predefinedType
    | constructedValueType
    | dynamicUnionType
    ;

typed
    =  whitespace doubleColon whitespace 
    | " TYPED "
    ;

predefinedType
    = booleanType
    | characterStringType
    | byteStringType
    | numericType
    | temporalType
    | referenceValueType
    | immaterialValueType
    ;

booleanType
    = (" BOOL " | " BOOLEAN ") notNull?
    ;

characterStringType
    = " STRING " ( whitespace leftParen whitespace  (minLength whitespace  comma whitespace )? maxLength whitespace  rightParen whitespace )? notNull?
    | " CHAR " ( whitespace leftParen whitespace  fixedLength whitespace  rightParen whitespace )? notNull?
    | " VARCHAR " ( whitespace leftParen whitespace  maxLength whitespace  rightParen whitespace )? notNull?
    ;

byteStringType
    = " BYTES " ( whitespace leftParen whitespace  (minLength whitespace  comma whitespace )? maxLength whitespace  rightParen whitespace )? notNull?
    | " BINARY " ( whitespace leftParen whitespace  fixedLength whitespace  rightParen whitespace )? notNull?
    | " VARBINARY " ( whitespace leftParen whitespace  maxLength whitespace  rightParen whitespace )? notNull?
    ;

minLength
    = unsignedInteger
    ;

maxLength
    = unsignedInteger
    ;

fixedLength
    = unsignedInteger
    ;

numericType
    = exactNumericType
    | approximateNumericType
    ;

exactNumericType
    = binaryExactNumericType
    | decimalExactNumericType
    ;

binaryExactNumericType
    = signedBinaryExactNumericType
    | unsignedBinaryExactNumericType
    ;

signedBinaryExactNumericType
    = " INT8 " notNull?
    | " INT16 " notNull?
    | " INT32 " notNull?
    | " INT64 " notNull?
    | " INT128 " notNull?
    | " INT256 " notNull?
    | " SMALLINT " notNull?
    | " INT " ( whitespace leftParen whitespace  precision whitespace  rightParen whitespace )? notNull?
    | " BIGINT " notNull?
    | " SIGNED "? verboseBinaryExactNumericType
    ;

unsignedBinaryExactNumericType
    = " UINT8 " notNull?
    | " UINT16 " notNull?
    | " UINT32 " notNull?
    | " UINT64 " notNull?
    | " UINT128 " notNull?
    | " UINT256 " notNull?
    | " USMALLINT " notNull?
    | " UINT " ( whitespace leftParen whitespace  precision whitespace  rightParen whitespace )? notNull?
    | " UBIGINT " notNull?
    | " UNSIGNED " verboseBinaryExactNumericType
    ;

verboseBinaryExactNumericType
    = " INTEGER8 " notNull?
    | " INTEGER16 " notNull?
    | " INTEGER32 " notNull?
    | " INTEGER64 " notNull?
    | " INTEGER128 " notNull?
    | " INTEGER256 " notNull?
    | " SMALL " " INTEGER " notNull?
    | " INTEGER " ( whitespace leftParen whitespace  precision whitespace  rightParen whitespace )? notNull?
    | " BIG " " INTEGER " notNull?
    ;

decimalExactNumericType
    = (" DECIMAL " | " DEC ") ( whitespace leftParen whitespace  precision ( whitespace comma whitespace  scale)? whitespace  rightParen whitespace  notNull?)?
    ;

precision
    = unsignedDecimalInteger
    ;

scale
    = unsignedDecimalInteger
    ;

approximateNumericType
    = " FLOAT16 " notNull?
    | " FLOAT32 " notNull?
    | " FLOAT64 " notNull?
    | " FLOAT128 " notNull?
    | " FLOAT256 " notNull?
    | " FLOAT " ( whitespace leftParen whitespace  precision ( whitespace comma whitespace  scale)? whitespace  rightParen whitespace )? notNull?
    | " REAL " notNull?
    | " DOUBLE " " PRECISION "? notNull?
    ;

temporalType
    = temporalInstantType
    | temporalDurationType
    ;

temporalInstantType
    = datetimeType
    | localdatetimeType
    | dateType
    | timeType
    | localtimeType
    ;

datetimeType
    = " ZONED " " DATETIME " notNull?
    | " TIMESTAMP " " WITH " " TIME " " ZONE " notNull?
    ;

localdatetimeType
    = " LOCAL " " DATETIME " notNull?
    | " TIMESTAMP " (" WITHOUT " " TIME " " ZONE ")? notNull?
    ;

dateType
    = " DATE " notNull?
    ;

timeType
    = " ZONED " " TIME " notNull?
    | " TIME " " WITH " " TIME " " ZONE " notNull?
    ;

localtimeType
    = " LOCAL " " TIME " notNull?
    | " TIME " " WITHOUT " " TIME " " ZONE " notNull?
    ;

temporalDurationType
    = " DURATION " whitespace  leftParen whitespace  temporalDurationQualifier whitespace  rightParen whitespace  notNull?
    ;

temporalDurationQualifier
    = " YEAR " " TO " " MONTH "
    | " DAY " " TO " " SECOND "
    ;

referenceValueType
    = graphReferenceValueType
    | bindingTableReferenceValueType
    | nodeReferenceValueType
    | edgeReferenceValueType
    ;

immaterialValueType
    = nullType
    | emptyType
    ;

nullType
    = " NULL "
    ;

emptyType
    = " NULL " notNull
    | " NOTHING "
    ;

graphReferenceValueType
    = openGraphReferenceValueType
    | closedGraphReferenceValueType
    ;

closedGraphReferenceValueType
    = " PROPERTY "? " GRAPH " nestedGraphTypeSpecification notNull?
    ;

openGraphReferenceValueType
    = " ANY " " PROPERTY "? " GRAPH " notNull?
    ;

bindingTableReferenceValueType
    = bindingTableType notNull?
    ;

nodeReferenceValueType
    = openNodeReferenceValueType
    | closedNodeReferenceValueType
    ;

closedNodeReferenceValueType
    = nodeTypeSpecification notNull?
    ;

openNodeReferenceValueType
    = " ANY "? nodeSynonym notNull?
    ;

edgeReferenceValueType
    = openEdgeReferenceValueType
    | closedEdgeReferenceValueType
    ;

closedEdgeReferenceValueType
    = edgeTypeSpecification notNull?
    ;

openEdgeReferenceValueType
    = " ANY "? edgeSynonym notNull?
    ;

constructedValueType
    = pathValueType
    | listValueType
    | recordType
    ;

pathValueType
    = " PATH " notNull?
    ;

listValueType
    = (listValueTypeName whitespace  leftAngleBracket whitespace  valueType whitespace  rightAngleBracket whitespace  | valueType? listValueTypeName) ( whitespace leftBracket whitespace  maxLength whitespace  rightBracket whitespace )? notNull?
    ;

listValueTypeName
    = " GROUP "? listValueTypeNameSynonym
    ;

listValueTypeNameSynonym
    = " LIST "
    | " ARRAY "
    ;

recordType
    = " ANY "? " RECORD " notNull?
    | " RECORD "? fieldTypesSpecification notNull?
    ;

fieldTypesSpecification
    =  whitespace leftBrace whitespace  fieldTypeList? whitespace  rightBrace whitespace 
    ;

fieldTypeList
    = fieldType (( whitespace comma whitespace  fieldType)+)?
    ;

dynamicUnionType
    = openDynamicUnionType
    | dynamicPropertyValueType
    | closedDynamicUnionType
    ;

openDynamicUnionType
    = " ANY " " VALUE "? notNull?
    ;

dynamicPropertyValueType
    = " ANY "? " PROPERTY " " VALUE " notNull?
    ;

closedDynamicUnionType
    = " ANY " " VALUE "? whitespace  leftAngleBracket whitespace  componentTypeList whitespace  rightAngleBracket whitespace 
    | componentTypeList
    ;

componentTypeList
    = componentType (( whitespace verticalBar whitespace  componentType)+)?
    ;

componentType
    = valueType
    ;

notNull
    = "  NOT " " NULL "
    ;

fieldType
    = fieldName typed? valueType
    ;

searchCondition
    = booleanValueExpression
    ;

predicate
    = comparisonPredicate
    | existsPredicate
    | nullPredicate
    | normalizedPredicate
    | valueTypePredicate
    | directedPredicate
    | labeledPredicate
    | sourceDestinationPredicate
    | all_differentPredicate
    | samePredicate
    | property_existsPredicate
    ;

comparisonPredicate
    = comparisonPredicand comparisonPredicatePart2
    ;

comparisonPredicatePart2
    = compOp comparisonPredicand
    ;

compOp
    =  whitespace equalsOperator whitespace 
    |  whitespace notEqualsOperator whitespace 
    | lessThanOperator
    | greaterThanOperator
    |  whitespace lessThanOrEqualsOperator whitespace 
    |  whitespace greaterThanOrEqualsOperator whitespace 
    ;

comparisonPredicand
    = commonValueExpression
    | booleanPredicand
    ;

existsPredicate
    = " EXISTS " ( whitespace leftBrace whitespace  graphPattern whitespace  rightBrace whitespace  |  whitespace leftParen whitespace  graphPattern whitespace  rightParen whitespace  |  whitespace leftBrace whitespace  matchStatementBlock whitespace  rightBrace whitespace  |  whitespace leftParen whitespace  matchStatementBlock whitespace  rightParen whitespace  | nestedQuerySpecification)
    ;

nullPredicate
    = valueExpressionPrimary nullPredicatePart2
    ;

nullPredicatePart2
    = " IS " " NOT "? " NULL "
    ;

valueTypePredicate
    = valueExpressionPrimary valueTypePredicatePart2
    ;

valueTypePredicatePart2
    = " IS " " NOT "? typed valueType
    ;

normalizedPredicate
    = stringValueExpression normalizedPredicatePart2
    ;

normalizedPredicatePart2
    = " IS " " NOT "? normalForm? " NORMALIZED "
    ;

directedPredicate
    = elementVariableReference directedPredicatePart2
    ;

directedPredicatePart2
    = " IS " " NOT "? " DIRECTED "
    ;

labeledPredicate
    = elementVariableReference labeledPredicatePart2
    ;

labeledPredicatePart2
    = isLabeledOrColon labelExpression
    ;

isLabeledOrColon
    = " IS " " NOT "? " LABELED "
    |  whitespace colon whitespace 
    ;

sourceDestinationPredicate
    = nodeReference sourcePredicatePart2
    | nodeReference destinationPredicatePart2
    ;

nodeReference
    = elementVariableReference
    ;

sourcePredicatePart2
    = " IS " " NOT "? " SOURCE " " OF " edgeReference
    ;

destinationPredicatePart2
    = " IS " " NOT "? " DESTINATION " " OF " edgeReference
    ;

edgeReference
    = elementVariableReference
    ;

all_differentPredicate
    = " ALL_DIFFERENT " whitespace  leftParen whitespace  elementVariableReference whitespace  comma whitespace  elementVariableReference (( whitespace comma whitespace  elementVariableReference)+)? whitespace  rightParen whitespace 
    ;

samePredicate
    = " SAME " whitespace  leftParen whitespace  elementVariableReference whitespace  comma whitespace  elementVariableReference (( whitespace comma whitespace  elementVariableReference)+)? whitespace  rightParen whitespace 
    ;

property_existsPredicate
    = " PROPERTY_EXISTS " whitespace  leftParen whitespace  elementVariableReference whitespace  comma whitespace  propertyName whitespace  rightParen whitespace 
    ;

valueExpression
    = commonValueExpression
    | booleanValueExpression
    ;

commonValueExpression
    = numericValueExpression
    | stringValueExpression
    | datetimeValueExpression
    | durationValueExpression
    | listValueExpression
    | recordExpression
    | pathValueExpression
    | referenceValueExpression
    ;

referenceValueExpression
    = graphReferenceValueExpression
    | bindingTableReferenceValueExpression
    | nodeReferenceValueExpression
    | edgeReferenceValueExpression
    ;

graphReferenceValueExpression
    = " PROPERTY "? " GRAPH " graphExpression
    | valueExpressionPrimary
    ;

bindingTableReferenceValueExpression
    = " BINDING "? " TABLE " bindingTableExpression
    | valueExpressionPrimary
    ;

nodeReferenceValueExpression
    = valueExpressionPrimary
    ;

edgeReferenceValueExpression
    = valueExpressionPrimary
    ;

recordExpression
    = valueExpressionPrimary
    ;

aggregatingValueExpression
    = valueExpression
    ;

valueExpressionPrimary
    = parenthesizedValueExpression
    | nonParenthesizedValueExpressionPrimary
    ;

parenthesizedValueExpression
    =  whitespace leftParen whitespace  valueExpression whitespace  rightParen whitespace 
    ;

nonParenthesizedValueExpressionPrimary
    = nonParenthesizedValueExpressionPrimarySpecialCase
    | bindingVariableReference
    ;

nonParenthesizedValueExpressionPrimarySpecialCase
    = aggregateFunction
    | unsignedValueSpecification
    | listValueConstructor
    | recordConstructor
    | pathValueConstructor
    | propertyReference
    | valueQueryExpression
    | caseExpression
    | castSpecification
    | element_idFunction
    | letValueExpression
    ;

unsignedValueSpecification
    = unsignedLiteral
    | generalValueSpecification
    ;

nonNegativeIntegerSpecification
    = unsignedInteger
    | dynamicParameterSpecification
    ;

generalValueSpecification
    = dynamicParameterSpecification
    | " SESSION_USER "
    ;

dynamicParameterSpecification
    = generalParameterReference
    ;

letValueExpression
    = " LET " letVariableDefinitionList " IN " valueExpression " END "
    ;

valueQueryExpression
    = " VALUE " nestedQuerySpecification
    ;

caseExpression
    = caseAbbreviation
    | caseSpecification
    ;

caseAbbreviation
    = " NULLIF " whitespace  leftParen whitespace  valueExpression whitespace  comma whitespace  valueExpression whitespace  rightParen whitespace 
    | " COALESCE " whitespace  leftParen whitespace  valueExpression ( whitespace comma whitespace  valueExpression)+ whitespace  rightParen whitespace 
    ;

caseSpecification
    = simpleCase
    | searchedCase
    ;

simpleCase
    = " CASE " caseOperand simpleWhenClause+ elseClause? " END "
    ;

searchedCase
    = " CASE " searchedWhenClause+ elseClause? " END "
    ;

simpleWhenClause
    = " WHEN " whenOperandList " THEN " result
    ;

searchedWhenClause
    = " WHEN " searchCondition " THEN " result
    ;

elseClause
    = " ELSE " result
    ;

caseOperand
    = nonParenthesizedValueExpressionPrimary
    | elementVariableReference
    ;

whenOperandList
    = whenOperand (( whitespace comma whitespace  whenOperand)+)?
    ;

whenOperand
    = nonParenthesizedValueExpressionPrimary
    | comparisonPredicatePart2
    | nullPredicatePart2
    | valueTypePredicatePart2
    | normalizedPredicatePart2
    | directedPredicatePart2
    | labeledPredicatePart2
    | sourcePredicatePart2
    | destinationPredicatePart2
    ;

result
    = resultExpression
    | nullLiteral
    ;

resultExpression
    = valueExpression
    ;

castSpecification
    = " CAST " whitespace  leftParen whitespace  castOperand " AS " castTarget whitespace  rightParen whitespace 
    ;

castOperand
    = valueExpression
    | nullLiteral
    ;

castTarget
    = valueType
    ;

aggregateFunction
    = " COUNT " whitespace  leftParen whitespace  whitespace  asterisk whitespace  whitespace  rightParen whitespace 
    | generalSetFunction
    | binarySetFunction
    ;

generalSetFunction
    = generalSetFunctionType whitespace  leftParen whitespace  setQuantifier? valueExpression whitespace  rightParen whitespace 
    ;

binarySetFunction
    = binarySetFunctionType whitespace  leftParen whitespace  dependentValueExpression whitespace  comma whitespace  independentValueExpression whitespace  rightParen whitespace 
    ;

generalSetFunctionType
    = " AVG "
    | " COUNT "
    | " MAX "
    | " MIN "
    | " SUM "
    | " COLLECT_LIST "
    | " STDDEV_SAMP "
    | " STDDEV_POP "
    ;

setQuantifier
    = " DISTINCT "
    | " ALL "
    ;

binarySetFunctionType
    = " PERCENTILE_CONT "
    | " PERCENTILE_DISC "
    ;

dependentValueExpression
    = setQuantifier? numericValueExpression
    ;

independentValueExpression
    = numericValueExpression
    ;

element_idFunction
    = " ELEMENT_ID " whitespace  leftParen whitespace  elementVariableReference whitespace  rightParen whitespace 
    ;

propertyReference
    = propertySource whitespace  period whitespace  propertyName
    ;

propertySource
    = nodeReferenceValueExpression
    | edgeReferenceValueExpression
    | recordExpression
    ;

bindingVariableReference
    = bindingVariable
    ;

pathValueExpression
    = pathValueConcatenation
    | pathValuePrimary
    ;

pathValueConcatenation
    = pathValueExpression1 whitespace  concatenationOperator whitespace  pathValuePrimary
    ;

pathValueExpression1
    = pathValueExpression
    ;

pathValuePrimary
    = valueExpressionPrimary
    ;

pathValueConstructor
    = pathValueConstructorByEnumeration
    ;

pathValueConstructorByEnumeration
    = " PATH " whitespace  leftBracket whitespace  pathElementList whitespace  rightBracket whitespace 
    ;

pathElementList
    = pathElementListStart (pathElementListStep+)?
    ;

pathElementListStart
    = nodeReferenceValueExpression
    ;

pathElementListStep
    =  whitespace comma whitespace  edgeReferenceValueExpression whitespace  comma whitespace  nodeReferenceValueExpression
    ;

listValueExpression
    = listConcatenation
    | listPrimary
    ;

listConcatenation
    = listValueExpression1 whitespace  concatenationOperator whitespace  listPrimary
    ;

listValueExpression1
    = listValueExpression
    ;

listPrimary
    = listValueFunction
    | valueExpressionPrimary
    ;

listValueFunction
    = trimListFunction
    | elementsFunction
    ;

trimListFunction
    = " TRIM " whitespace  leftParen whitespace  listValueExpression whitespace  comma whitespace  numericValueExpression whitespace  rightParen whitespace 
    ;

elementsFunction
    = " ELEMENTS " whitespace  leftParen whitespace  pathValueExpression whitespace  rightParen whitespace 
    ;

listValueConstructor
    = listValueConstructorByEnumeration
    ;

listValueConstructorByEnumeration
    = listValueTypeName? whitespace  leftBracket whitespace  listElementList? whitespace  rightBracket whitespace 
    ;

listElementList
    = listElement (( whitespace comma whitespace  listElement)+)?
    ;

listElement
    = valueExpression
    ;

recordConstructor
    = " RECORD "? fieldsSpecification
    ;

fieldsSpecification
    =  whitespace leftBrace whitespace  fieldList? whitespace  rightBrace whitespace 
    ;

fieldList
    = field (( whitespace comma whitespace  field)+)?
    ;

field
    = fieldName whitespace  colon whitespace  valueExpression
    ;

booleanValueExpression
    = booleanTerm
    | booleanValueExpression " OR " booleanTerm
    | booleanValueExpression " XOR " booleanTerm
    ;

booleanTerm
    = booleanFactor
    | booleanTerm " AND " booleanFactor
    ;

booleanFactor
    = " NOT "? booleanTest
    ;

booleanTest
    = booleanPrimary (" IS " " NOT "? truthValue)?
    ;

truthValue
    = " TRUE "
    | " FALSE "
    | " UNKNOWN "
    ;

booleanPrimary
    = predicate
    | booleanPredicand
    ;

booleanPredicand
    = parenthesizedBooleanValueExpression
    | nonParenthesizedValueExpressionPrimary
    ;

parenthesizedBooleanValueExpression
    =  whitespace leftParen whitespace  booleanValueExpression whitespace  rightParen whitespace 
    ;

numericValueExpression
    = term
    | numericValueExpression whitespace  plusSign whitespace  term
    | numericValueExpression whitespace  minusSign whitespace  term
    ;

term
    = factor
    | term whitespace  asterisk whitespace  factor
    | term whitespace  solidus whitespace  factor
    ;

factor
    = sign? numericPrimary
    ;

numericPrimary
    = valueExpressionPrimary
    | numericValueFunction
    ;

numericValueFunction
    = lengthExpression
    | cardinalityExpression
    | absoluteValueExpression
    | modulusExpression
    | trigonometricFunction
    | generalLogarithmFunction
    | commonLogarithm
    | naturalLogarithm
    | exponentialFunction
    | powerFunction
    | squareRoot
    | floorFunction
    | ceilingFunction
    ;

lengthExpression
    = charLengthExpression
    | byteLengthExpression
    | pathLengthExpression
    ;

cardinalityExpression
    = " CARDINALITY " whitespace  leftParen whitespace  cardinalityExpressionArgument whitespace  rightParen whitespace 
    | " SIZE " whitespace  leftParen whitespace  listValueExpression whitespace  rightParen whitespace 
    ;

cardinalityExpressionArgument
    = bindingTableReferenceValueExpression
    | pathValueExpression
    | listValueExpression
    | recordExpression
    ;

charLengthExpression
    = (" CHAR_LENGTH " | " CHARACTER_LENGTH ") whitespace  leftParen whitespace  characterStringValueExpression whitespace  rightParen whitespace 
    ;

byteLengthExpression
    = (" BYTE_LENGTH " | " OCTET_LENGTH ") whitespace  leftParen whitespace  byteStringValueExpression whitespace  rightParen whitespace 
    ;

pathLengthExpression
    = " PATH_LENGTH " whitespace  leftParen whitespace  pathValueExpression whitespace  rightParen whitespace 
    ;

absoluteValueExpression
    = " ABS " whitespace  leftParen whitespace  numericValueExpression whitespace  rightParen whitespace 
    ;

modulusExpression
    = " MOD " whitespace  leftParen whitespace  numericValueExpressionDividend whitespace  comma whitespace  numericValueExpressionDivisor whitespace  rightParen whitespace 
    ;

numericValueExpressionDividend
    = numericValueExpression
    ;

numericValueExpressionDivisor
    = numericValueExpression
    ;

trigonometricFunction
    = trigonometricFunctionName whitespace  leftParen whitespace  numericValueExpression whitespace  rightParen whitespace 
    ;

trigonometricFunctionName
    = " SIN "
    | " COS "
    | " TAN "
    | " COT "
    | " SINH "
    | " COSH "
    | " TANH "
    | " ASIN "
    | " ACOS "
    | " ATAN "
    | " DEGREES "
    | " RADIANS "
    ;

generalLogarithmFunction
    = " LOG " whitespace  leftParen whitespace  generalLogarithmBase whitespace  comma whitespace  generalLogarithmArgument whitespace  rightParen whitespace 
    ;

generalLogarithmBase
    = numericValueExpression
    ;

generalLogarithmArgument
    = numericValueExpression
    ;

commonLogarithm
    = " LOG10 " whitespace  leftParen whitespace  numericValueExpression whitespace  rightParen whitespace 
    ;

naturalLogarithm
    = " LN " whitespace  leftParen whitespace  numericValueExpression whitespace  rightParen whitespace 
    ;

exponentialFunction
    = " EXP " whitespace  leftParen whitespace  numericValueExpression whitespace  rightParen whitespace 
    ;

powerFunction
    = " POWER " whitespace  leftParen whitespace  numericValueExpressionBase whitespace  comma whitespace  numericValueExpressionExponent whitespace  rightParen whitespace 
    ;

numericValueExpressionBase
    = numericValueExpression
    ;

numericValueExpressionExponent
    = numericValueExpression
    ;

squareRoot
    = " SQRT " whitespace  leftParen whitespace  numericValueExpression whitespace  rightParen whitespace 
    ;

floorFunction
    = " FLOOR " whitespace  leftParen whitespace  numericValueExpression whitespace  rightParen whitespace 
    ;

ceilingFunction
    = (" CEIL " | " CEILING ") whitespace  leftParen whitespace  numericValueExpression whitespace  rightParen whitespace 
    ;

stringValueExpression
    = characterStringValueExpression
    | byteStringValueExpression
    ;

characterStringValueExpression
    = characterStringConcatenation
    | characterStringPrimary
    ;

characterStringConcatenation
    = characterStringValueExpression whitespace  concatenationOperator whitespace  characterStringPrimary
    ;

characterStringPrimary
    = valueExpressionPrimary
    | characterStringFunction
    ;

byteStringValueExpression
    = byteStringConcatenation
    | byteStringPrimary
    ;

byteStringPrimary
    = valueExpressionPrimary
    | byteStringFunction
    ;

byteStringConcatenation
    = byteStringValueExpression whitespace  concatenationOperator whitespace  byteStringPrimary
    ;

characterStringFunction
    = substringFunction
    | fold
    | trimFunction
    | normalizeFunction
    ;

substringFunction
    = (" LEFT " | " RIGHT ") whitespace  leftParen whitespace  characterStringValueExpression whitespace  comma whitespace  stringLength whitespace  rightParen whitespace 
    ;

fold
    = (" UPPER " | " LOWER ") whitespace  leftParen whitespace  characterStringValueExpression whitespace  rightParen whitespace 
    ;

trimFunction
    = singleCharacterTrimFunction
    | multiCharacterTrimFunction
    ;

singleCharacterTrimFunction
    = " TRIM " whitespace  leftParen whitespace  trimOperands whitespace  rightParen whitespace 
    ;

multiCharacterTrimFunction
    = (" BTRIM " | " LTRIM " | " RTRIM ") whitespace  leftParen whitespace  trimSource ( whitespace comma whitespace  trimCharacterString)? whitespace  rightParen whitespace 
    ;

trimOperands
    = (trimSpecification? trimCharacterString? " FROM ")? trimSource
    ;

trimSource
    = characterStringValueExpression
    ;

trimSpecification
    = " LEADING "
    | " TRAILING "
    | " BOTH "
    ;

trimCharacterString
    = characterStringValueExpression
    ;

normalizeFunction
    = " NORMALIZE " whitespace  leftParen whitespace  characterStringValueExpression ( whitespace comma whitespace  normalForm)? whitespace  rightParen whitespace 
    ;

normalForm
    = " NFC "
    | " NFD "
    | " NFKC "
    | " NFKD "
    ;

stringLength
    = numericValueExpression
    ;

byteStringFunction
    = byteStringSubstringFunction
    | byteStringTrimFunction
    ;

byteStringSubstringFunction
    = (" LEFT " | " RIGHT ") whitespace  leftParen whitespace  byteStringValueExpression whitespace  comma whitespace  stringLength whitespace  rightParen whitespace 
    ;

byteStringTrimFunction
    = " TRIM " whitespace  leftParen whitespace  byteStringTrimOperands whitespace  rightParen whitespace 
    ;

byteStringTrimOperands
    = (trimSpecification? trimByteString? " FROM ")? byteStringTrimSource
    ;

byteStringTrimSource
    = byteStringValueExpression
    ;

trimByteString
    = byteStringValueExpression
    ;

datetimeValueExpression
    = datetimePrimary
    | durationValueExpression whitespace  plusSign whitespace  datetimePrimary
    | datetimeValueExpression whitespace  plusSign whitespace  durationTerm
    | datetimeValueExpression whitespace  minusSign whitespace  durationTerm
    ;

datetimePrimary
    = valueExpressionPrimary
    | datetimeValueFunction
    ;

datetimeValueFunction
    = dateFunction
    | timeFunction
    | datetimeFunction
    | localtimeFunction
    | localdatetimeFunction
    ;

dateFunction
    = " CURRENT_DATE "
    | " DATE " whitespace  leftParen whitespace  dateFunctionParameters? whitespace  rightParen whitespace 
    ;

timeFunction
    = " CURRENT_TIME "
    | " ZONED_TIME " whitespace  leftParen whitespace  timeFunctionParameters? whitespace  rightParen whitespace 
    ;

localtimeFunction
    = " LOCAL_TIME " ( whitespace leftParen whitespace  timeFunctionParameters? whitespace  rightParen whitespace )?
    ;

datetimeFunction
    = " CURRENT_TIMESTAMP "
    | " ZONED_DATETIME " whitespace  leftParen whitespace  datetimeFunctionParameters? whitespace  rightParen whitespace 
    ;

localdatetimeFunction
    = " LOCAL_TIMESTAMP "
    | " LOCAL_DATETIME " whitespace  leftParen whitespace  datetimeFunctionParameters? whitespace  rightParen whitespace 
    ;

dateFunctionParameters
    = dateString
    | recordConstructor
    ;

timeFunctionParameters
    = timeString
    | recordConstructor
    ;

datetimeFunctionParameters
    = datetimeString
    | recordConstructor
    ;

durationValueExpression
    = durationTerm
    | durationAdditionAndSubtraction
    | datetimeSubtraction
    ;

durationAdditionAndSubtraction
    = durationValueExpression1 whitespace  plusSign whitespace  durationTerm1
    | durationValueExpression1 whitespace  minusSign whitespace  durationTerm1
    ;

datetimeSubtraction
    = " DURATION_BETWEEN " whitespace  leftParen whitespace  datetimeSubtractionParameters whitespace  rightParen whitespace  temporalDurationQualifier?
    ;

datetimeSubtractionParameters
    = datetimeValueExpression1 whitespace  comma whitespace  datetimeValueExpression2
    ;

durationTerm
    = durationFactor
    | durationTerm2 whitespace  asterisk whitespace  factor
    | durationTerm2 whitespace  solidus whitespace  factor
    | term whitespace  asterisk whitespace  durationFactor
    ;

durationFactor
    = sign? durationPrimary
    ;

durationPrimary
    = valueExpressionPrimary
    | durationValueFunction
    ;

durationValueExpression1
    = durationValueExpression
    ;

durationTerm1
    = durationTerm
    ;

durationTerm2
    = durationTerm
    ;

datetimeValueExpression1
    = datetimeValueExpression
    ;

datetimeValueExpression2
    = datetimeValueExpression
    ;

durationValueFunction
    = durationFunction
    | durationAbsoluteValueFunction
    ;

durationFunction
    = " DURATION " whitespace  leftParen whitespace  durationFunctionParameters whitespace  rightParen whitespace 
    ;

durationFunctionParameters
    = durationString
    | recordConstructor
    ;

durationAbsoluteValueFunction
    = " ABS " whitespace  leftParen whitespace  durationValueExpression whitespace  rightParen whitespace 
    ;

objectName
    = identifier
    ;

objectNameOrBindingVariable
    = regularIdentifier
    ;

directoryName
    = identifier
    ;

schemaName
    = identifier
    ;

graphName
    = regularIdentifier
    | delimitedGraphName
    ;

delimitedGraphName
    = delimitedIdentifier
    ;

graphTypeName
    = identifier
    ;

nodeTypeName
    = identifier
    ;

edgeTypeName
    = identifier
    ;

bindingTableName
    = regularIdentifier
    | delimitedBindingTableName
    ;

delimitedBindingTableName
    = delimitedIdentifier
    ;

procedureName
    = identifier
    ;

labelName
    = identifier
    ;

propertyName
    = identifier
    ;

fieldName
    = identifier
    ;

parameterName
    = separatedIdentifier
    ;

elementVariable
    = bindingVariable
    ;

pathVariable
    = bindingVariable
    ;

subpathVariable
    = regularIdentifier
    ;

bindingVariable
    = regularIdentifier
    ;

unsignedLiteral
    = unsignedNumericLiteral
    | generalLiteral
    ;

generalLiteral
    = booleanLiteral
    | characterStringLiteral
    | byteStringLiteral
    | temporalLiteral
    | durationLiteral
    | nullLiteral
    | listLiteral
    | recordLiteral
    ;

booleanLiteral
    = " TRUE "
    | " FALSE "
    | " UNKNOWN "
    ;

characterStringLiteral
    = singleQuotedCharacterSequence
    | doubleQuotedCharacterSequence
    ;

singleQuotedCharacterSequence
    = noEscape? unbrokenSingleQuotedCharacterSequence
    ;

doubleQuotedCharacterSequence
    = noEscape? unbrokenDoubleQuotedCharacterSequence
    ;

accentQuotedCharacterSequence
    = noEscape? unbrokenAccentQuotedCharacterSequence
    ;

noEscape
    =  commercialAt
    ;

unbrokenSingleQuotedCharacterSequence
    =   quote (singleQuotedCharacterRepresentation+)? quote whitespace 
    ;

unbrokenDoubleQuotedCharacterSequence
    =   doubleQuote (doubleQuotedCharacterRepresentation+)? doubleQuote whitespace 
    ;

unbrokenAccentQuotedCharacterSequence
    =   graveAccent  (accentQuotedCharacterRepresentation+)? graveAccent whitespace 
    ;

singleQuotedCharacterRepresentation
    = characterRepresentation
    ;

doubleQuotedCharacterRepresentation
    = characterRepresentation
    ;

accentQuotedCharacterRepresentation
    = characterRepresentation
    ;

characterRepresentation
    = "a" | "b" | "c"
    ;

byteStringLiteral
    = "X" quote hexDigit hexDigit quote
    ;

sign
    =  plusSign 
    |  minusSign 
    ;

unsignedNumericLiteral
    = exactNumericLiteral
    | approximateNumericLiteral
    ;

exactNumericLiteral
    = unsignedDecimalInScientificNotation exactNumberSuffix whitespace 
    | unsignedDecimalInCommonNotation exactNumberSuffix whitespace ?
    | unsignedDecimalInteger exactNumberSuffix whitespace 
    | unsignedInteger
    ;

exactNumberSuffix
    = "M"
    ;

unsignedDecimalInScientificNotation
    = mantissa "E" exponent
    ;

mantissa
    = unsignedDecimalInCommonNotation
    | unsignedDecimalInteger
    ;

exponent
    = signedDecimalInteger
    ;

unsignedDecimalInCommonNotation
    = unsignedDecimalInteger (  period   unsignedDecimalInteger?)
    |  whitespace period  unsignedDecimalInteger
    ;

unsignedInteger
    = unsignedDecimalInteger
    | unsignedHexadecimalInteger
    | unsignedOctalInteger
    | unsignedBinaryInteger
    ;

signedDecimalInteger
    = sign? unsignedDecimalInteger
    ;

unsignedDecimalInteger
    = digit (( underscore? digit)+)?
    ;

unsignedHexadecimalInteger
    = "0x" ( underscore? hexDigit)+
    ;

unsignedOctalInteger
    = "0o" ( underscore? octalDigit)+
    ;

unsignedBinaryInteger
    = "0b" ( underscore? binaryDigit)+
    ;

approximateNumericLiteral
    = unsignedDecimalInScientificNotation approximateNumberSuffix?
    | unsignedDecimalInCommonNotation approximateNumberSuffix
    | unsignedDecimalInteger approximateNumberSuffix
    ;

approximateNumberSuffix
    = "F"
    | "D"
    ;

temporalLiteral
    = dateLiteral
    | timeLiteral
    | datetimeLiteral
    ;

dateLiteral
    = " DATE " dateString
    ;

timeLiteral
    = " TIME " timeString
    ;

datetimeLiteral
    = (" DATETIME " | " TIMESTAMP ") datetimeString
    ;

dateString
    = characterStringLiteral
    ;

timeString
    = characterStringLiteral
    ;

datetimeString
    = characterStringLiteral
    ;

timeZoneString
    = characterStringLiteral
    ;

durationLiteral
    = " DURATION " durationString
    ;

durationString
    = characterStringLiteral
    ;

nullLiteral
    = " NULL "
    ;

listLiteral
    = listValueConstructorByEnumeration
    ;

recordLiteral
    = recordConstructor
    ;

identifier
    = regularIdentifier
    | delimitedIdentifier
    ;

separatedIdentifier
    = extendedIdentifier
    | delimitedIdentifier
    ;

regularIdentifier
    = identifierStart (identifierExtend+)?
    ;

extendedIdentifier
    = identifierExtend+
    ;

delimitedIdentifier
    = doubleQuotedCharacterSequence
    | accentQuotedCharacterSequence
    ;

identifierStart
    = "a" | "b" | "c"
    ;

identifierExtend
    = "a" | "b" | "c"
    ;

substitutedParameterReference
    =  whitespace doubleDollarSign parameterName
    ;

generalParameterReference
    =  whitespace dollarSign parameterName
    ;

multisetAlternationOperator
    = "|+|"
    ;

bracketRightArrow
    = "]->"
    ;

bracketTildeRightArrow
    = "]~>"
    ;

concatenationOperator
    = "||"
    ;

doubleColon
    = "::"
    ;

doubleDollarSign
    = "$$"
    ;

doublePeriod
    = ".."
    ;

greaterThanOperator
    =  whitespace rightAngleBracket whitespace 
    ;

greaterThanOrEqualsOperator
    = ">="
    ;

leftArrow
    = "<-"
    ;

leftArrowTilde
    = "<~"
    ;

leftArrowBracket
    = "<-["
    ;

leftArrowTildeBracket
    = "<~["
    ;

leftMinusRight
    = "<->"
    ;

leftMinusSlash
    = "<-/"
    ;

leftTildeSlash
    = "<~/"
    ;

lessThanOperator
    =  whitespace leftAngleBracket whitespace 
    ;

lessThanOrEqualsOperator
    = "<="
    ;

minusLeftBracket
    = "-["
    ;

minusSlash
    = "-/"
    ;

notEqualsOperator
    = "<>"
    ;

rightArrow
    = "->"
    ;

rightBracketMinus
    = "]-"
    ;

rightBracketTilde
    = "]~"
    ;

rightDoubleArrow
    = "=>"
    ;

slashMinus
    = "/-"
    ;

slashMinusRight
    = "/->"
    ;

slashTilde
    = "/~"
    ;

slashTildeRight
    = "/~>"
    ;

tildeLeftBracket
    = "~["
    ;

tildeRightArrow
    = "~>"
    ;

tildeSlash
    = "~/"
    ;

whitespace
    = " "
    ;

edgeSynonym
    = " EDGE "
    | " RELATIONSHIP "
    ;

edgesSynonym
    = " EDGES "
    | " RELATIONSHIPS "
    ;

nodeSynonym
    = " NODE "
    | " VERTEX "
    ;

implies
    =  whitespace rightDoubleArrow whitespace 
    | " IMPLIES "
    ;

hexDigit
    = standardDigit
    | "A"
    | "B"
    | "C"
    | "D"
    | "E"
    | "F"
    | "a"
    | "b"
    | "c"
    | "d"
    | "e"
    | "f"
    ;

digit
    = standardDigit
    ;

standardDigit
    = octalDigit
    | "8"
    | "9"
    ;

octalDigit
    = binaryDigit
    | "2"
    | "3"
    | "4"
    | "5"
    | "6"
    | "7"
    ;

binaryDigit
    = "0"
    | "1"
    ;

ampersand
    = "&"
    ;

asterisk
    = "*"
    ;

colon
    = ":"
    ;

comma
    = ","
    ;

commercialAt
    = "@"
    ;

dollarSign
    = "$"
    ;

doubleQuote
    = "\""
    ;

equalsOperator
    = "="
    ;

exclamationMark
    = "!"
    ;

rightAngleBracket
    = ">"
    ;

graveAccent
    = "`"
    ;

leftBrace
    = "{"
    ;

leftBracket
    = "["
    ;

leftParen
    = "("
    ;

leftAngleBracket
    = "<"
    ;

minusSign
    = "-"
    ;

percent
    = "%"
    ;

period
    = "."
    ;

plusSign
    = "+"
    ;

questionMark
    = "?"
    ;

quote
    = "'"
    ;

rightBrace
    = "}"
    ;

rightBracket
    = "]"
    ;

rightParen
    = ")"
    ;

solidus
    = "/"
    ;

tilde
    = "~"
    ;

underscore
    = "_"
    ;

verticalBar
    = "|"
    ;
